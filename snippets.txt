{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"Boilerplate": {
		"prefix": "Boilerplate Code",
		"body": [
			"#include \"bits/stdc++.h\"",
			"#ifndef ONLINE_JUDGE",
            "#include \"debug.h\"",
            "#else",
            "#define dbg(x...)",
            "#endif",
			"using namespace std;",
			"using ll = long long;",
			"#define int ll",
			"#define endl '\\n'",
			"const int mod = 1000000007;",
			"// clang-format off",
			 "template<typename typC,typename typD> istream &operator>>(istream &cin,pair<typC,typD> &a) { return cin>>a.first>>a.second; }",
                   "template<typename typC> istream &operator>>(istream &cin,vector<typC> &a) { for (auto &x:a) cin>>x; return cin; }",
                   "template<typename typC,typename typD> ostream &operator<<(ostream &cout,const pair<typC,typD> &a) { return cout<<a.first<<' '<<a.second; }",
                   "template<typename typC,typename typD> ostream &operator<<(ostream &cout,const vector<pair<typC,typD>> &a) { for (auto &x:a) cout<<x<<'\\n'; return cout; }",
                   "template<typename typC> ostream &operator<<(ostream &cout,const vector<typC> &a) { int n=a.size(); if (!n) return cout; cout<<a[0]; for (int i=1; i<n; i++) cout<<' '<<a[i]; return cout; }",
			"// clang-format on",
			"\n",
			"void solve()",
			"{",
			"    ll t, m, n, a, b;",
			"    string h;",
			"    $0",
			"}",
			"int32_t main()",
			"{",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(0);",
			"#ifndef ONLINE_JUDGE",
    		"    freopen(\"input.txt\", \"r\", stdin);",
    		"    freopen(\"output.txt\", \"w\", stdout);",
    		"#endif",
			"    int t;",
			"    cin >> t;",
			"    while (t--)",
			"    {",
			"        solve();",
			"    }",
			"    return 0;",
			"}"
		],
		"description": ""
	},
	"": {
  "prefix": "Custom Hash",
  "body": [
    "struct custom_hash",
    "{",
    "    static uint64_t splitmix64(uint64_t x)",
    "    {",
    "        // http://xorshift.di.unimi.it/splitmix64.c",
    "        x += 0x9e3779b97f4a7c15;",
    "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
    "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
    "        return x ^ (x >> 31);",
    "    }",
    "",
    "    size_t operator()(uint64_t x) const",
    "    {",
    "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
    "        return splitmix64(x + FIXED_RANDOM);",
    "    }",
    "};"
  ],
  "description": ""
},
	"BigInt": {
		"prefix": "BigInt",
		"body": [
			"using INT = __int128;"
		],
		"description": ""
	},
	"OptimisedSnippet": {
		"prefix": "Optimised Snippet",
		"body": [
			"ll Count(vector<ll> Sorted_arr, int x, int n)",
			"{",
			"    auto low = lower_bound(Sorted_arr.begin(), Sorted_arr.end(), x);",
			"    if (low == Sorted_arr.end() || *low != x)",
			"        return 0;",
			"    auto high = upper_bound(low, Sorted_arr.end(), x);",
			"    return high - low;",
			"}",
			"vector<ll> getPrefixSum(vector<int>arr, int n)",
			"{",
			"    vector<ll>prefixSum(n);",
			"    prefixSum[0] = arr[0];",
			"    for (int i = 1; i < n; i++)",
			"        prefixSum[i] = prefixSum[i - 1] + arr[i];",
			"    return prefixSum;",
			"}",
			"vector<ll> getPrefix_Mex(vector<int> &A, int n)",
			"{",
			"    int mx_element = *max_element(A.begin(), A.end());",
			"    set<int> s;",
			"    for (int i = 0; i <= mx_element + 1; i++)",
			"        s.insert(i);",
			"    vector<ll> B(n);",
			"    for (int i = 0; i < n; i++)",
			"    {",
			"        auto it = s.find(A[i]);",
			"        if (it != s.end())",
			"            s.erase(it);",
			"        B[i] = *s.begin();",
			"    }",
			"    return B;",
			"}",
			"ll power(int x, int n)",
			"{",
			"    int result = 1;",
			"    while (n > 0)",
			"    {",
			"        if (n & 1 == 1)",
			"        {",
			"            result = result * x;",
			"        }",
			"        x = x * x;",
			"        n = n >> 1;",
			"    }",
			"    return result;",
			"}",
			"bool isPrime(int n)",
			"{",
			"    if (n <= 1)",
			"        return 0;",
			"    if (n == 2 || n == 3)",
			"        return 1;",
			"    if (n % 2 == 0 || n % 3 == 0)",
			"        return 0;",
			"    for (int i = 5; i * i <= n; i = i + 6)",
			"        if (n % i == 0 || n % (i + 2) == 0)",
			"            return 0;",
			"    return 1;",
			"}",
			"vector<ll> sieve(int n)",
			"{",
			"    vector<ll> ans;",
			"    vector<bool> v(n + 1, 1);",
			"    for (int i = 2; i <= n; i++)",
			"    {",
			"        if (v[i])",
			"        {",
			"            ans.push_back(i);",
			"            for (int j = i * i; j <= n; j = j + i)",
			"                v[j] = 0;",
			"        }",
			"    }",
			"    return ans;",
			"}",
			"map<ll, ll> printPrimeFactors(int n)",
			"{",
			"    map<ll, ll> mp;",
			"    if (n <= 1)",
			"        return mp;",
			"    while (n % 2 == 0)",
			"    {",
			"        mp[2]++;",
			"        n /= 2;",
			"    }",
			"    while (n % 3 == 0)",
			"    {",
			"        mp[3]++;",
			"        n /= 3;",
			"    }",
			"    for (int i = 5; i * i <= n; i += 6)",
			"    {",
			"        while (n % i == 0)",
			"        {",
			"            mp[i]++;",
			"            n /= i;",
			"        }",
			"        while (n % (i + 2) == 0)",
			"        {",
			"            mp[i + 2]++;",
			"            n /= (i + 2);",
			"        }",
			"    }",
			"    if (n > 3)",
			"        mp[n]++;",
			"    return mp;",
			"}",
			"long long lcm(int a, int b)",
			"{",
			"    return (a / __gcd(a, b)) * b;",
			"}",
			"ll fact(int n)",
			"{",
			"    ll res = 1, i;",
			"    for (i = 2; i <= n; i++)",
			"        res *= i;",
			"    return res;",
			"}",
			"ll nCr(int n, int r)",
			"{",
			"    return fact(n) / (fact(r) * fact(n - r));",
			"}",
			"ll nPr(int n, int r)",
			"{",
			"    return fact(n) / fact(n - r);",
			"}",
		],
		"description": "Log output to console"
	},
	"header": {
		"prefix": "Header file Code",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
		],
		"description": "Log output to console"
	},
	"CM snippet": {
		"prefix": "Candidate Master's Snippet",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"#define endl '\\n'",
			"#define mod 1000000007",
			"const int Len = 2333;",
			"char buf[Len], *p1 = buf, *p2 = buf, duf[Len], *q1 = duf;",
			"inline char CHAR()",
			"{",
			"    return p1 == p2 && (p2 = (p1 = buf) + fread(buf, 1, Len, stdin), p1 == p2) ? -1 : *p1++;",
			"}",
			"inline int INT()",
			"{",
			"    char c;",
			"    while (!isdigit(c = CHAR()) && c != '-')",
			"        ;",
			"    int f = c == '-' ? c = CHAR(), 1 : 0, x = c ^ 48;",
			"    while (isdigit(c = CHAR()))",
			"        x = ((x + (x << 2)) << 1) + (c ^ 48);",
			"    return f ? -x : x;",
			"}",
			"inline ll rdll()",
			"{",
			"    char c;",
			"    while (!isdigit(c = CHAR()) && c != '-')",
			"        ;",
			"    ll f = c == '-' ? c = CHAR(), 1 : 0, x = c ^ 48;",
			"    while (isdigit(c = CHAR()))",
			"        x = ((x + (x << 2)) << 1) + (c ^ 48);",
			"    return f ? -x : x;",
			"}",
			"inline string STRING(int n = 0)",
			"{",
			"    string s;",
			"    char c;",
			"    if (n)",
			"    {",
			"        int pos = 0;",
			"        s.resize(n);",
			"        while (isalpha(c = CHAR()) || isdigit(c))",
			"            s[pos++] = c;",
			"    }",
			"    else",
			"    {",
			"        while (isalpha(c = CHAR()) || isdigit(c))",
			"            s += c;",
			"    }",
			"    return s;",
			"}",
			"template <typename typC, typename typD>",
			"istream &operator>>(istream &cin, pair<typC, typD> &a)",
			"{",
			"    return cin >> a.first >> a.second;",
			"}",
			"template <typename typC>",
			"istream &operator>>(istream &cin, vector<typC> &a)",
			"{",
			"    for (auto &x : a)",
			"        cin >> x;",
			"    return cin;",
			"}",
			"const int nmax = 500011;",
			"int mas[nmax];",
			"inline void flush()",
			"{",
			"    fwrite(duf, 1, q1 - duf, stdout);",
			"    q1 = duf;",
			"}",
			"inline void print(char c) { q1 == duf + Len &&fwrite(q1 = duf, 1, Len, stdout), *q1++ = c; }",
			"inline void print(string s)",
			"{",
			"    int n = s.size();",
			"    for (int i = 0; i < n; i++)",
			"        print(s[i]);",
			"}",
			"inline void print(int x) { x < 0 ? print('-'), x = -x : 0, print((x >= 10 ? print(x / 10), x % 10 : x) + 48); }",
			"inline void print(char c) { q1 == duf + Len &&fwrite(q1 = duf, 1, Len, stdout), *q1++ = c; }",
			"inline void print(ll x) { x < 0 ? print('-'), x = -x : 0, print((x >= 10 ? print(x / 10), x % 10 : x) + 48); }",
			"inline void print(string s)",
			"{",
			"    int n = s.size();",
			"    for (int i = 0; i < n; i++)",
			"        print(s[i]);",
			"}",
			"void solve()",
			"{",
			"    int t, m, n, a, b;",
			"    string h;",
			"    n = INT();",
			"    $0",
			"}",
			"int main()",
			"{",
			"    ios::sync_with_stdio(false);",
			"    cin.tie(0);",
			"    srand(2);",
			"    int t;",
			"    t = INT();",
			"    while (t--)",
			"    {",
			"        solve();",
			"    }",
			"    flush();",
			"    return 0;",
			"}"
		],
		"description": ""
	},
	"Ordered set": {
		"prefix": "OrderedSet",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"#define pbds tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update>",
			"// finding the kth element",
			"// cout<< *A.find_by_order(0);",
			"// no. of elements smaller than x",
			"// cout<<A.order_of_key(7);",
			"// lower bound",
			"// cout<<*A.lower_bound(0);",
			"// upper bound",
			"// cout<<*A.upper_bound(0);",
			"// Remove elements",
			"// A.erase(1);",
			""
		],
		"description": ""
	},
	"Segment Tree": {
  "prefix": "Segment Tree",
  "body": [
    "class SegmentTree{",
    "    public:",
    "    vector<int> tree;",
    "    int n;",
    "    SegmentTree(vector<int>& v){",
    "        n=v.size();",
    "        tree.assign(4*n,0);",
    "        buildTree(1,0,n-1,v);",
    "    }",
    "    void buildTree(int node,int l,int r,vector<int>& v){",
    "        if(l>r) return;",
    "        if(l==r){",
    "            tree[node]=v[l];",
    "            return;",
    "        }",
    "        int mid=(l+r)/2;",
    "        buildTree(node*2,l,mid,v);",
    "        buildTree(node*2+1,mid+1,r,v);",
    "        tree[node]=tree[node*2]+tree[node*2+1];",
    "    }",
    "    int getValue(int l,int r){",
    "        return _getVal(l,r,0,n-1,1);",
    "    }",
    "    int _getVal(int l,int r,int tree_left,int tree_right,int node){",
    "        if(tree_right<tree_left)    return 0;",
    "        if(tree_left>=l && tree_right<=r){   // the entire substree is a part of the thing being queried",
    "            return tree[node];",
    "        }",
    "        if(tree_left>r || tree_right<l ) return 0;",
    "        if(tree_left==tree_right)   return tree[node];",
    "        int mid=(tree_left+tree_right)/2;",
    "        return _getVal(l,r,tree_left,mid,node*2)+_getVal(l,r,mid+1,tree_right,node*2+1);",
    "        ",
    "    }",
    "    void update(int idx,int newVal){",
    "        _update(idx,newVal,0,n-1,1);",
    "    }",
    "    void _update(int idx,int newVal,int tree_left,int tree_right,int node){",
    "        if(tree_left>idx || tree_right<idx) return;",
    "        if(tree_left==tree_right){",
    "            tree[node]=newVal;",
    "            return;",
    "        }",
    "        int mid=(tree_left+tree_right)/2;",
    "        _update(idx,newVal,tree_left,mid,node*2);",
    "        _update(idx,newVal,mid+1,tree_right,node*2+1);",
    "        tree[node]=tree[node*2]+tree[node*2+1];",
    "    }",
    "};"
  ],
  "description": ""
},
"Mint": {
  "prefix": "Mint",
  "body": [
    "template <const int T>",
    "struct ModInt",
    "{",
    "    const static int mod = T;",
    "    int x;",
    "    int val() { return x; }",
    "    // ModInt(int x = 0) : x(x % mod) {}",
    "    ModInt(long long x) : x(int(x % mod)) {}",
    "    ModInt operator+(const ModInt &a) const",
    "    {",
    "        int x0 = x + a.x;",
    "        return ModInt(x0 < mod ? x0 : x0 - mod);",
    "    }",
    "    ModInt operator-(const ModInt &a) const",
    "    {",
    "        int x0 = x - a.x;",
    "        return ModInt(x0 < 0 ? x0 + mod : x0);",
    "    }",
    "    ModInt operator*(const ModInt &a) const { return ModInt(1ll * x * a.x % mod); }",
    "    ModInt operator/(const ModInt &a) const { return *this * a.inv(); }",
    "    void operator+=(const ModInt &a)",
    "    {",
    "        x += a.x;",
    "        if (x >= mod)",
    "            x -= mod;",
    "    }",
    "    void operator-=(const ModInt &a)",
    "    {",
    "        x -= a.x;",
    "        if (x < 0)",
    "            x += mod;",
    "    }",
    "    void operator*=(const ModInt &a) { x = 1LL * x * a.x % mod; }",
    "    void operator/=(const ModInt &a) { *this = *this / a; }",
    "    ModInt pow(int64_t n) const",
    "    {",
    "        ModInt res(1), mul(x);",
    "        while (n)",
    "        {",
    "            if (n & 1)",
    "                res *= mul;",
    "            mul *= mul;",
    "            n >>= 1;",
    "        }",
    "        return res;",
    "    }",
    "    ModInt inv() const",
    "    {",
    "        int a = x, b = mod, u = 1, v = 0;",
    "        while (b)",
    "        {",
    "            int t = a / b;",
    "            a -= t * b;",
    "            swap(a, b);",
    "            u -= t * v;",
    "            swap(u, v);",
    "        }",
    "        if (u < 0)",
    "            u += mod;",
    "        return u;",
    "    }",
    "};",
    "typedef ModInt<mod> mint;",
    "",
    "// mint a = 2, b = 2;",
    "// a = a.pow(2 * n - 1);",
    "// b = b.pow(n - 1);",
    "// cout << (a + b).x << endl;"
  ],
  "description": ""
}
}